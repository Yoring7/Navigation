# SLAM视觉里程计小作业

> *娄昱乾 	2112003173*

​		视觉SLAM解决的就是定位与建图的问题，在前端视觉里程计中要完成的是根据相机采集的**图像**进行初步的构图与定位。第一步是对图像的处理，大致有两种方法：**特征点法**和**直接法**，下面讨论的是特征点法。

### 1. 特征点法

​		该方法就是对图像提取相应的特征点，然后对两帧图像上**相似的特征**进行匹配，以便后续利用匹配好的特征对**相机位姿**进行求解。目前主要的算法有：**SIFT**、**SURF**以及**ORB**算法，下面将利用**ORB**算法进行特征匹配。

- **ORB**方法步骤

  1. 提取改进的**Oriented FAST**角点

     - 只比较像素的**亮度大小**，速度非常快。

     - ORB还添加了**尺度**和**旋转**的描述（分别采用的是**构建图像金字塔**和**灰度质心法**），使得在平移、旋转等变换下算法仍有良好表现。

  2. 对每个角点计算**BRIEF**描述子

     - 这是一种**二进制**描述子，计算和存储的效率极高。

  3. 对特征进行匹配

     - 由于使用了**二进制**描述子，计算特征距离时采用**汉明距离**，即两个二进制字符串**不同位数的个数**，这样的计算效率是非常高的。

  4. 对匹配的特征点进行筛选

     - 计算最大距离和最小距离，当描述子之间的距离大于最小距离的两倍时，认为匹配有误。


### 2. 相机定位与建图

​		匹配好点对以后就可以根据点对来对相机的位姿进行估计。根据数据集和构图的维度不同，里程计进行位姿求解主要分为以下三种情形：

| 维度  | 解决方案 |
| :---: | :------: |
| 2D-2D | 对极几何 |
| 3D-2D |   PnP    |
| 3D-3D |   ICP    |

- #### 2D-2D: 对极几何

  1. 由针孔相机模型关系可知，*P*与像素点p1，p2的关系为：
     $$
     s_1p_1=KP,\;\;s_2p_2=K(RP+t)
     $$
     对两个像素点进行归一化投影，即将空间上的点都转到了相机前单位距离处：
     $$
     x_1=K^{-1}p_1,\;x_2=K^{-1}p_2
     $$
     再利用叉乘后得到垂直向量的技巧，构造出：
     $$
     x_2^Tt^\hat{}Rx_1=0
     $$
     重新代入p1，p2得到：
     $$
     p_2^TK^{-T}t^\hat{}RK^{-1}p_1=0
     $$
     以上两个式子就是对极约束，又可以简化写成：
     $$
     E=t^\hat{}R,\;F=K^{-T}EK^{-1},\;x_2^TEx_{1\;}=p_2^TFp_1=0
     $$
     于是，求解问题变成了求解*E*或*F*，进而求解出*R*和*t*。
     $$
     E=t^\hat{}R,\;F=K^{-T}EK^{-1},\;x_2^TEx_{1\;}=p_2^TFp_1=0
     $$

  2. **求解本质矩阵*E***，书上用的方法是线性代数的方法。由于其尺度等价性(观察上述对极约束的等式，对左边任意缩放，等式仍成立)，可以用**八点法**来求解。如果多于8对点，可以用**最小二乘**的方法来求解，这样同样也可以求出最小二乘意义下的*E*矩阵。

  3. 得到本质矩阵*E*后，就可以**恢复出相机运动的*R*和*t***。方法是对*E*进行**奇异值分解(SVD)**，这个过程会产生四组解，而只有一种解中*P*在两个相机中的深度都为正，即只有一个正确的解(OpenCV会帮我们检测角点的深度是否为正)。这样就利用两张图得到了相机运动的*R*和*t*。

  4. 已经确定了相机的位姿，下面要进行建图，也就是反推路标点的三维坐标。利用的方法是**三角测量**来估计其深度信息。而由于噪声的存在，两次观测的射线不一定交于*P*点，所以用求解最小二乘的方法来计算。

- #### 3D-2D: PnP

  ​		以上解决的是通过两张没有深度信息的图片进行定位和建图，而如果两张图中其中有一张的特征点的3D坐标已知，就可以用*PnP*的方法估计相机运动。求解*PnP*也有很多方法，如**P3P**、**直接线性变换（DLT）**等，还可以用**非线性优化**的方法来迭代求解，**光束法平差（BA）**。

  + **直接线性变换（DLT）**

    ​		由针孔相机模型将旋转和平移矩阵写到一起，可以得到一个3×4的曾广矩阵*[R|t]*，代入特征点即可解除矩阵中的每个元素。由于共有12个元素，而每对特征点能提供2个约束，所以最少6对特征点就可以进行线性求解。同样，大于6对时也可以用SVD等方法对方程求**最小二乘解**。

  + **非线性优化法**

    ​		之前的线性方法，一般是先求相机位姿，再求空间点位置，而非线性优化的方法把**两者放在一起优化**。要进行非线性优化，关键是找到目标函数，还有与优化变量相关的导数，之后便可以利用传统的**高斯牛顿法、列文伯格方法**进行迭代求解。

    1. **找目标函数**

       ​		通过特征匹配得到的*P*点的两个投影*p1、p2*由于**相机的位姿未知及观测点的噪声**，使得估计的投影点位置与实际位置之间存在误差，于是我们把误差求和，得到目标函数使其最小化：
       $$
       min\frac12\sum_{i=1}^n\left|\left|\left.\left.u_i-\frac1{s_i}KTP_i\right|\right|_2^2\right.\right.
       $$

    2. **求目标函数对于优化变量的导数**

       1. 优化位姿可以对齐次变换矩阵*T*左乘扰动量，考虑上述误差项*e*的变化关于扰动量的导数，可以用链式求导法则求导：
          $$
          \frac{\partial e}{\partial\delta\xi}=\frac{\partial e}{\partial\widetilde P}\frac{\partial\widetilde P}{\partial\delta\xi}
          $$

       2. 下面还需要优化特征点的空间位置，所以要误差项*e*对空间点*P*的导数，同样用链式求导法则求导：
          $$
          \frac{\partial e}{\partial P}=\frac{\partial e}{\partial\widetilde P}\frac{\partial\widetilde P}{\partial P}
          $$
          上述*detilde P*为相机坐标系下的空间点坐标，且提出了前三维。

    3. **利用优化算法进行迭代求解**

       ​		有了目标函数和导数即可利用常用的优化算法进行求解，比如**高斯牛顿法**，给定初值计算当前的雅克比矩阵和误差，求解增量方程，判断进给量是否小于阈值，如此循环，直到找到最优值。下面是利用高斯牛顿法迭代的核心代码：

       ```c++
       /// 开始高斯牛顿迭代，次数为10次
       for (int iter = 0; iter < iterations; iter++) {
           Eigen::Matrix<double, 6, 6> H = Eigen::Matrix<double, 6, 6>::Zero();
           Vector6d b = Vector6d::Zero();
           /// 定义损失值，用来储存目标函数值的变化
         	cost = 0;
           /// 计算目标函数在此迭代中的值，对匹配的点对统一计算
           for (int i = 0; i < points_3d.size(); i++) {
             Eigen::Vector3d pc = pose * points_3d[i];
             double inv_z = 1.0 / pc[2];
             double inv_z2 = inv_z * inv_z;
             Eigen::Vector2d proj(fx * pc[0] / pc[2] + cx, fy * pc[1] / pc[2] + cy);
             /// 得到目标函数，也就是误差的最小二乘
             Eigen::Vector2d e = points_2d[i] - proj;
             cost += e.squaredNorm();
             /// 计算雅克比矩阵
             Eigen::Matrix<double, 2, 6> J;
             J << -fx * inv_z,
               0,
               fx * pc[0] * inv_z2,
               fx * pc[0] * pc[1] * inv_z2,
               -fx - fx * pc[0] * pc[0] * inv_z2,
               fx * pc[1] * inv_z,
               0,
               -fy * inv_z,
               fy * pc[1] * inv_z,
               fy + fy * pc[1] * pc[1] * inv_z2,
               -fy * pc[0] * pc[1] * inv_z2,
               -fy * pc[0] * inv_z;
             
             /// 计算Hessian矩阵也就是JT×J
             H += J.transpose() * J;
             
             /// 计算方程的右边部分,即g(x)，也称为bais
             b += -J.transpose() * e;
           }
       
           /// 求解线性方程Hx=b
           Vector6d dx;
           dx = H.ldlt().solve(b);
         
         	/// 判断停止条件
           if (isnan(dx[0])) {
             cout << "result is nan!" << endl;
             break;
           }
           if (iter > 0 && cost >= lastCost) {
             // cost increase, update is not good
             cout << "cost: " << cost << ", last cost: " << lastCost << endl;
             break;
           }
       
           /// 更新函数值
           pose = Sophus::SE3d::exp(dx) * pose;
           lastCost = cost;
       }
       ```

       

- #### 3D-3D ICP

  ​		3D-3D的问题是想要找到配对好的一系列3D点之间的旋转平移关系，可以用**迭代最近点(ICP)**的方法求解，同样，也可以用**线性代数的方法（SVD）**与**非线性优化的方法（BA）**进行求解。

  - **SVD方法**

    首先同样构建最小二乘问题，目标是让误差的平方和最小：
    $$
    min{\textstyle\frac12}\sum_{i=1}^n\left|\left|\left.\left.p_i-(R\widetilde{p_i}+t)\right|\right|_2^2\right.\right.
    $$
    

    1. 计算两组点的**质心位置**，然后计算每个点的**去质心坐标**。
    2. 根据推导出的优化问题，计算旋转矩阵*R*。这里是关键，需要用到**SVD分解**的方法。
    3. 最后计算**平移矩阵*t***。

  - **非线性优化的方法**

    ​		使用非线性优化的方法，需要知道**目标函数**和相关优化变量的**导数**，用李代数来表达旋转平移关系，目标函数写成：
    $$
    min\xi=\frac12\sum_{i=1}^n\left|\left|\left.\left.p_i-exp(\xi^\hat{})\widetilde{p_i}\right|\right|\right._2^2\right.
    $$
    ​		导数可以使用李代数的扰动模型求解：
    $$
    \frac{\partial e}{\partial\delta\xi}=-(exp{(\xi^\hat{})\widetilde{p_i})}^\odot
    $$
    ​		同样，得到了目标函数和导数，下面可以用非线性优化的算法进行迭代求解，与PnP非线性优化流程类似。

  